# -*- coding: utf-8 -*-
"""quantedge20d110015

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hzPy58JP5OtauuIVaJ5sXV7crqt9SlV3
"""

# Import Required Libraries
import pandas as pd
import numpy as np
import datetime
import matplotlib.pyplot as plt
import seaborn as sns

# Declaring the Hyperparameters
N = 10
T = 7
R = 0.8
M = 5
F = 0.0005   # 0.5% Brokerage fee

# Function to Get Data
def GetData(NameOfFile):
    cols = ['tic', 'datadate', 'adjcp']
    return pd.read_csv(NameOfFile, usecols=cols)

# Function to Partition Data
def PartitionData(Data):
    DateToIndex = {}
    PartitionedData = []
    unique_dates = Data['datadate'].unique()

    for idx, date in enumerate(unique_dates):
        date_data = Data[Data['datadate'] == date]
        PartitionedData.append(date_data)
        DateToIndex[date] = idx

    return PartitionedData, DateToIndex

# Function to Get Momentum-Based Priority
def GetMomentumBasedPriority(PartitionedDataFrameList, DateToIndex, today, data):
    indexT = DateToIndex[today]
    dfT = PartitionedDataFrameList[indexT]

    NdaysAgo = datetime.date(int(str(today)[:4]), int(str(today)[4:6]), int(str(today)[6:])) - datetime.timedelta(days=N)
    NdaysAgoInt = int(NdaysAgo.strftime('%Y%m%d'))

    while NdaysAgoInt not in DateToIndex:
        NdaysAgo += datetime.timedelta(days=-1)
        NdaysAgoInt = int(NdaysAgo.strftime('%Y%m%d'))

    indexN = DateToIndex[NdaysAgoInt]
    dfN = PartitionedDataFrameList[indexN]

    dtype = np.dtype([('tic', 'U10'), ('adjcpT', float), ('adjcpN', float), ('momentum', float)])
    result = np.zeros((30,), dtype=dtype)

    result['tic'] = dfT['tic']
    result['adjcpT'] = dfT['adjcp']
    result['adjcpN'] = dfN['adjcp']
    result['momentum'] = result['adjcpT'] - result['adjcpN']

    Utic = data['tic'].unique()
    for ticker in Utic:
        df_ticker = data[data['tic'] == ticker]
        df_ticker.reset_index(drop=True, inplace=True)

        idxT = df_ticker.index[df_ticker['datadate'] == today][0]
        idxN = df_ticker.index[df_ticker['datadate'] == NdaysAgoInt][0]

        selected_rows = df_ticker.loc[idxN:idxT]
        mean_values = selected_rows['adjcp'].mean()

        index = np.where(result['tic'] == ticker)
        result['momentum'][index] = result['momentum'][index] / mean_values

    return np.sort(result, order='momentum')[::-1]

# Function to Get Balanced Portfolio
def GetBalanced(prices, weights, balance):
    weight = weights['momentum']
    normalized_weights = weight / np.sum(weight)
    allocated_balance = normalized_weights * balance

    number_of_shares = np.zeros(M)
    for i in range(M):
        tic = newWeights['tic'][i]
        k = np.where(prices[:, 0] == tic)[0]
        number_of_shares[i] = allocated_balance[i] / prices[k, 1]

    return np.floor(number_of_shares)

# Portfolio Class
class PortFolio:
    def __init__(self, Ibal, Cbal, Cstocks, prices):
        self.Ibal = Ibal
        self.Cbal = Cbal
        self.Cstocks = np.array(Cstocks, dtype=object)
        self.prices = np.array(prices, dtype=object)

    def SellStock(self, index):
        money = self.prices[index, 1] * self.Cstocks[index, 1] * (1 - F)
        self.Cbal += money
        self.Cstocks[index, 1] = 0

    def BuyStock(self, index, number):
        money = self.prices[index, 1] * number * (1 + F)
        self.Cbal -= money
        self.Cstocks[index, 1] += number

    def CalculateNetWorth(self):
        return np.dot(self.prices[:, 1], self.Cstocks[:, 1]) + self.Cbal

    def ChangePricesTo(self, newPriceVector):
        self.prices[:, 1] = newPriceVector

    def RebalancePortFolio(self, newWeights):
        def GetBalanced(prices, weights, balance):
            weight = weights['momentum']
            normalized_weights = weight / np.sum(weight)
            allocated_balance = normalized_weights * balance

            number_of_shares = np.zeros(M)
            for i in range(M):
                tic = newWeights['tic'][i]
                k = np.where(self.prices[:, 0] == tic)[0]
                number_of_shares[i] = allocated_balance[i] / self.prices[k, 1]

            return np.floor(number_of_shares)

        for i in range(30):
            if self.Cstocks[i, 1] > 0:
                self.SellStock(i)

        shares_to_buy = GetBalanced(self.prices, newWeights, self.Cbal)
        for i in range(M):
            tic = newWeights['tic'][i]
            k = np.where(self.prices[:, 0] == tic)[0]
            if shares_to_buy[i] > 0:
                self.BuyStock(k, shares_to_buy[i])

# Initialize Portfolio
Ibal = 10000
Cbal = Ibal
data = [["AAPL", 0], ["AXP", 0], ["BA", 0], ["CAT", 0], ["CSCO", 0], ["CVX", 0], ["DD", 0], ["DIS", 0], ["GS", 0], ["HD", 0], ["IBM", 0], ["INTC", 0], ["JNJ", 0], ["JPM", 0], ["KO", 0], ["MCD", 0], ["MMM", 0], ["MRK", 0], ["MSFT", 0], ["NKE", 0], ["PFE", 0], ["PG", 0], ["RTX", 0], ["TRV", 0], ["UNH", 0], ["V", 0], ["VZ", 0], ["WBA", 0], ["WMT", 0], ["XOM", 0]]
Cstocks = np.array(data, dtype=object)
prices = np.array(data, dtype=object)

myPortfolio = PortFolio(Ibal, Cbal, Cstocks, prices)
NetWorthAfterEachTrade = []

# Get the Data
Data = GetData('/content/DATA.csv')
PartitionedData, DateToIndex = PartitionData(Data)

# Process Data
for i in range(N, len(DateToIndex)):
    df = PartitionedData[i]
    today = df['datadate'].iloc[0]
    prices = df['adjcp'].to_numpy()
    myPortfolio.ChangePricesTo(prices)

    # Record Net Worth
    net_worth = myPortfolio.CalculateNetWorth()
    NetWorthAfterEachTrade.append(int(net_worth))

    # Rebalance Portfolio if Necessary
    if i % T == 0:
        weights = GetMomentumBasedPriority(PartitionedData, DateToIndex, today, Data)
        top_indices = np.arange(min(M, 30))
        myPortfolio.RebalancePortFolio(weights[top_indices])

# Function to Visualize Data
def VisualizeData(NetWorthAfterEachTrade):
    plt.figure(figsize=(10, 6))
    dates = pd.date_range(start='2009-01-01', periods=len(NetWorthAfterEachTrade), freq='B')
    plt.plot(dates, NetWorthAfterEachTrade, label='Net Worth')
    plt.title('Net Worth Over Time')
    plt.xlabel('Time')
    plt.ylabel('Net Worth')
    plt.legend()
    plt.grid(True)
    plt.show()

# Visualize Net Worth
VisualizeData(NetWorthAfterEachTrade)